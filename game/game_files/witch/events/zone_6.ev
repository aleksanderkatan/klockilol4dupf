6 2
None
Co? Znowu dwa takie same poziomy? Niemożliwe


6 5
None
No dobra, to teraz trochę grubsze ciekawostki.
Być może nauczyciel fizyki uczył cię kiedyś liczyć pierwiastek z liczby przy użyciu prostego kalkulatora.
nowy_wynik = 1/2 * (stary_wynik + liczba_którą_pierwiastkujesz/stary_wynik)
I tak sobie powtarzasz, zaczynając od byle czego, przybliżasz się do pierwiastka liczby. To się nazywa metodą Newtona i można nią liczyć wiele różnych funkcji.
Twórcy Quake III Arena potrzebowali szybko liczyć 1/pierwiastek(a). Użyli podobnej metody, ale zoptymalizowali ją w opór. Teraz, jak wygooglujesz "quake what the fuck", dostaniesz w wynikach "fast inverse square root"! Wraz z tym paskudnym kawałkiem kodu.


6 7
None
Ten "what the fuck algorithm" był możliwy dzięki temu, że C nie jest type safe.
Znaczy może się okazać w runtimie że ktoś próbuje do siebie dodać zamiast liczb np. konia i wóz asenizacyjny.
C jest tak bardzo nie type safe jak tylko się da. Każdy typ można zcastować na void*, a potem zreinterpretować jako coś innego.
Można nawet w połowę struktury się wbić.
Gorszy jest chyba tylko asembler, gdzie można wykonać skok instruction pointera do połowy instrukcji, a procesor to łyknie i będzie wykonywał jakieś mambo dżambo.


6 9
None
Nice.
Rozwiązywałeś kiedyś Jolki?
Powiedzmy, że masz daną krzyżówkę i już poprawnie odgadłeś, jakie hasła będziesz do niej wpisywał, tylko jeszcze nie wiesz które gdzie, bo podpowiedzi nie były obok slotów tylko pod krzyżówką.
Jeżeli byłbyś w stanie efektywnie rozwiązywać ten problem (czyli odpowiadać "da się wypełnić" albo "nie da się wypełnić"), zawaliło by to świat informatyczny.
Konsekwencją tego byłoby, że ogromna część programistów straciłaby pracę, a sporo algorytmów zostałoby drastycznie przyspieszonych.
No i sporo systemów zabezpieczeń by siadło, ludzie by mogli czytać twoje maile i być może włamać się do twojego banku.
Wszystko jest konsekwencją tego, że problem krzyżówki jest NP-zupełny.
A w tym poziomie lód jest postawiony nieprzypadkowo.


6 13
None
Większość programów w c++ da się sprowadzić do równoważnych mających 1 średnik. Takim głównym trikiem jest wrzucenie wszystkiego do ifów.
Zamiast
+a = 3;
+piszesz
+if(a=3) {}
Zamiast
+cin >> s;
+piszesz
+if(cin >> s) {}
Ten jeden średnik jest potrzebny do deklarowania zmiennych. int a, b, c[1000000];
Jak chcesz inny typ danych, na przykład jednego stringa - nic trudnego!
pair<int, string>a, b, c[1000000], s;
+Po prostu ignoruj ten dodatkowy syf.


6 16
None
A jak już jesteśmy przy średnikach, w c# jest LINQ, czyli system zapytań zintegrowanych z językiem. Jest to taki śmieszny miks c# z SQLem i można w nim robić selecty itp.
Da się napisać zapytanie, które wczytuje graf z stdina i wypisuje na stdout liczbę spójnych składowych i ich rozmiary.
Kod bez forów, whilów czy rekurencji, nawet modyfikowania zmiennych. Mamy tylko deklarowanie zmiennych i Aggregate. Chcesz wczytać 10 liczb i wypisać ich sumę?
let input = (from i in Enumerable.Range(0, 10) select Console.ReadLine().ToString()).ToList()
+let wynik = input.Aggregate((x, y) => x+y)
+select Console.WriteLine(wynik)
No i to nam pozwala pisać kod w cpp-like języku z 1 średnikiem. Deklaracja go pochłania, potem invoke na tym można wywołać w ifie.